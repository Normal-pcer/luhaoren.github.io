<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【算法笔记】线段树</title>
    <link href="/2023/07/09/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2023/07/09/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>今年初的时候学线段树，凑了一篇博客（其实就是一堆题的题解），连线段树是什么都没讲明白，所以重新写了一篇。</p><h1>线段树的引入</h1><p>举个例子，我们现在有一个序列，想维护一段子区间的和，该怎么办呢？</p><p>你或许会说，可以暴力！把这个区间的数加起来就行了。</p><p>那么如果这个子区间里有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>个数呢？</p><p>前缀和？</p><p>如果强制在线呢？</p><p>如果在维护区间和的同时维护最大值、并且支持区间修改呢？</p><p>我们有很多种办法维护区间问题，比如树状数组，线段树，分块。其中，线段树是较通用且直观的一种数据结构。</p><h1>基础线段树</h1><h2 id="线段树入门">线段树入门</h2><p>首先，我们有一个序列。</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left \{ 1,1,4,5,1,4 \right \} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span></p><p>我们利用二分的思想，用每一个节点表示一个区间，两个子节点表示左右两个子区间。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ryyqv01h.png" alt=""><br>然后我们就可以在每个节点处维护一些信息。</p><p>注意：实际上，只有最下面一层的叶子节点才保存了实际的数字，其它的每个节点只保存着这个区间的信息（如区间和，区间最值等）</p><p>那么如何把子节点的信息传到父节点上呢？</p><p>我们要了解一个叫做<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>u</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">pushup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span></span></span></span>的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>tr[x].sum=tr[x*<span class="hljs-number">2</span>].sum+tr[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个操作的意思就是：节点表示的区间和等于两个子节点所表示的区间之和。即下图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/cnvm8qso.png" alt=""><br>有了这个操作，我们就可以递归的求出每一个节点所表示的信息。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vkn6fj17.png" alt=""><br>这个建立线段树的过程可以看作是预处理信息，把数组的信息转移到线段树的叶子节点上，时间复杂度大概是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>事实上，还有另一种写法的线段树，不需要建树，但是需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O( n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的时间复杂度插入数据，我们会在权值线段树部分介绍这种写法。</p><p><strong>建树代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>tr[x].l=l,tr[x].r=r;<span class="hljs-comment">//节点表示区间的左右界</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br><span class="hljs-comment">//若l=r，说明这个节点是叶子节点，直接赋值</span><br>tr[x].sum=a[l];<span class="hljs-comment">//a是原数列</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-comment">//mid表示左右子区间的间隔</span><br><span class="hljs-built_in">build</span>(x*<span class="hljs-number">2</span>,l,mid),<span class="hljs-built_in">build</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归建树</span><br><span class="hljs-comment">//线段树是完全二叉树，左右子节点可以用x*2,x*2+1表示</span><br>tr[x].sum=tr[x*<span class="hljs-number">2</span>].sum+tr[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//pushup操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间查询">区间查询</h3><p>线段树可以在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的时间复杂度下完成区间查询操作。</p><p>以刚刚的数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left \{ 1,1,4,5,1,4 \right \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>为例。</p><p>此时如果询问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>之间的区间和，我们该怎么办呢？</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/a3c7wf82.png" alt=""><br>首先，如果直接查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>的区间和，我们肯定是会的，直接输出10就行。</p><p>查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>怎么办呢？</p><p>可以把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>拆成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>6</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[6,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>，然后输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>的和。</p><p>那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>就可以表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ej610u3t.png" alt=""><br>所以无论我们查询多大的区间，都可以拆成一些（不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span>）预处理过的子区间，把这些子区间的区间和加起来，就是答案。</p><p><strong>区间查询代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-comment">//区间查询</span><br><span class="hljs-keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&gt;=r) <span class="hljs-keyword">return</span> tr[x].sum;<span class="hljs-comment">//如果该节点的区间被要查找的区间包括了，那么就不用继续找了，直接返回改节点的值就行了</span><br><span class="hljs-type">int</span> mid=(tr[x].l+tr[x].r)/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>,l,r);<span class="hljs-comment">//如果当前节点在要查找区间左边界的右面，那么递归查找左子树</span><br><span class="hljs-keyword">if</span>(r&gt;mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r);<span class="hljs-comment">//如果当前节点在要查找区间右边界的左面，那么递归查找右子树</span><br><span class="hljs-keyword">return</span> sum;<span class="hljs-comment">//由此得出了该区间的值，返回即可</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单点修改">单点修改</h3><p>单点修改比较简单，不断递归，定位到要找的节点，修改即可。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hccrowdz.png" alt="单点修改"></p><p><strong>单点修改代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">//单点修改</span><br><span class="hljs-keyword">if</span>(tr[now].l==tr[now].r)&#123;<br>tr[now].sum=k;<span class="hljs-comment">//如果找到了该节点，那么修改它</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(tr[now].l+tr[now].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">change</span>(now*<span class="hljs-number">2</span>,x,k);<span class="hljs-comment">//如果要寻找的节点在当前节点的左侧，就递归左子树</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(now*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,x,k);<span class="hljs-comment">//否则递归右子树</span><br>tr[now].sum=tr[now*<span class="hljs-number">2</span>].sum+tr[now*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//pushup操作，维护每个节点的sum值</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树的存储">线段树的存储</h3><p>观察线段树，我们发现它是一个完全二叉树，可以用堆式储存法。</p><p>即把每个节点都存在一个数组里，因为是完全二叉树，所以两个子节点可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>p</mi></mrow><annotation encoding="application/x-tex">2p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal">p</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2p+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>表示。</p><p>因为线段树大部分节点都不是用来存数字的，所以线段树所用的空间要比原数列的空间多很多，如图，只有红色的节点才是真正存数字的。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/l271t0zv.png" alt="线段树的存储"></p><p>线段树大概要开四倍的空间，具体可以看<a href="https://oi-wiki.org/ds/seg/#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%BB%BA%E6%A0%91">OIwiki</a>上的分析。</p><h3 id="例题1：单点修改，区间查询">例题1：单点修改，区间查询</h3><p><a href="https://www.luogu.com.cn/problem/P3374">洛谷P3374</a></p><p>已知一个数列，进行下面两种操作：</p><ul><li>将某一个数加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></li><li>求出某区间每一个数的和</li></ul><p><strong>题目分析</strong></p><p>相当于模板题，可以尝试着敲一遍，这里提供代码。</p><p><strong>AC代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> sum,l,r;<span class="hljs-comment">//线段树节点的结构体</span><br>&#125;tr[N*<span class="hljs-number">4</span>];<span class="hljs-comment">//线段树需要开四倍空间</span><br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>tr[x].sum=tr[x*<span class="hljs-number">2</span>].sum+tr[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>tr[x].l=l,tr[x].r=r;<span class="hljs-comment">//节点表示区间的左右界</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br><span class="hljs-comment">//若l=r，说明这个节点是叶子节点，直接赋值</span><br>tr[x].sum=a[l];<span class="hljs-comment">//a是原数列</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-comment">//mid表示左右子区间的间隔</span><br><span class="hljs-built_in">build</span>(x*<span class="hljs-number">2</span>,l,mid),<span class="hljs-built_in">build</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归建树</span><br><span class="hljs-comment">//线段树是完全二叉树，左右子节点可以用x*2,x*2+1表示</span><br><span class="hljs-built_in">pushup</span>(x);<span class="hljs-comment">//pushup操作</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-comment">//区间查询</span><br><span class="hljs-keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r) <span class="hljs-keyword">return</span> tr[x].sum;<span class="hljs-comment">//如果该节点的区间被要查找的区间包括了，那么就不用继续找了，直接返回改节点的值就行了</span><br><span class="hljs-type">int</span> mid=(tr[x].l+tr[x].r)/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>,l,r);<span class="hljs-comment">//如果当前节点在要查找区间左边界的右面，那么递归查找左子树</span><br><span class="hljs-keyword">if</span>(r&gt;mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r);<span class="hljs-comment">//如果当前节点在要查找区间右边界的左面，那么递归查找右子树</span><br><span class="hljs-keyword">return</span> sum;<span class="hljs-comment">//由此得出了该区间的值，返回即可</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">//单点修改</span><br><span class="hljs-keyword">if</span>(tr[now].l==tr[now].r)&#123;<br>tr[now].sum+=k;<span class="hljs-comment">//如果找到了该节点，那么修改它</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(tr[now].l+tr[now].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">change</span>(now*<span class="hljs-number">2</span>,x,k);<span class="hljs-comment">//如果要寻找的节点在当前节点的左侧，就递归左子树</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(now*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,x,k);<span class="hljs-comment">//否则递归右子树</span><br><span class="hljs-built_in">pushup</span>(now);<span class="hljs-comment">//pushup操作，维护每个节点的sum值</span><br>&#125;<br><br><span class="hljs-type">int</span> n,q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-comment">//建树</span><br><span class="hljs-keyword">while</span>(q--)&#123;<br><span class="hljs-type">int</span> t,b,c;<br>cin&gt;&gt;t&gt;&gt;b&gt;&gt;c;<br><span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>) <span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>,b,c);<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,b,c)&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="习题">习题</h3><p>学会了线段树最基础的部分，就可以做一些习题了，将在博客的最后提供题解和代码。</p><ol><li><a href="https://www.luogu.com.cn/problem/P1198">JSOI2008 最大数</a><br>线段树维护最大值的模板</li><li><a href="https://loj.ac/p/10123">loj10123. Balanced Lineup</a><br>RMQ问题，可以试试用线段树做</li></ol><h2 id="懒标记">懒标记</h2><p>下面请思考，怎么才能做到线段树的区间修改呢？</p><p>如果直接把区间遍历一遍，依次修改，复杂度会达到无法接受的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>那么怎么能让区间修改的复杂度变小呢？</p><p>我们需要引入一个叫做“懒标记”的东西。</p><p>懒标记也叫延迟标记，顾名思义，我们再修改这个区间的时候给这个区间打上一个标记，这样就可以做到区间修改的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的时间复杂度。</p><p>如图，如果要给<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>每个数都加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，那么直接再代表着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>区间的结点打上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">2</span></span></span></span>的标记就行了。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/couf82jr.png" alt="懒标记"></p><h3 id="pushdown操作">pushdown操作</h3><p>再想一个问题，在给<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>区间打上懒标记后，我们如何查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>的值？</p><p>如果我们直接查询到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>区间上，会发现根本就没有被加上过2。</p><p>为什么呢?</p><p>因为现在懒标记打在了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>区间上。而他的子节点压根没被修改过！</p><p>所以我们需要把懒标记向下传递。</p><p>这就有了一个操作，叫做<code>pushdown</code>，它可以把懒标记下传。</p><p>设想一下，如果我们要把懒标记下传，应该注意什么呢？</p><p>首先，要给子节点打上懒标记。</p><p>然后，我们要修改子节点上的值。</p><p>最后，不要忘记把这个节点的懒标记清空。</p><p><strong>pushdown代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushudown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(tr[x].add)&#123;<br><span class="hljs-comment">//如果这个节点上有懒标记</span><br>tr[<span class="hljs-number">2</span>*x].add+=tr[x].add,tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].add+=tr[x].add;<br><span class="hljs-comment">//把这个节点的懒标记给他的两个子节点</span><br>tr[<span class="hljs-number">2</span>*x].sum+=tr[x].add*(tr[<span class="hljs-number">2</span>*x].r-tr[<span class="hljs-number">2</span>*x].l+<span class="hljs-number">1</span>);<br>tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].sum+=tr[x].add*(tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].r-tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br><span class="hljs-comment">//分别给它的两个子节点修改</span><br>tr[x].add=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//别忘了清空这个节点的懒标记</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间修改">区间修改</h3><p>学会了懒标记，应该可以很轻松地写出区间修改的代码了。</p><p>区间修改的操作很像区间查询，也是查找能够覆盖住的子区间，然后给它打上懒标记。</p><p><strong>区间查询代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&lt;=tr[now].l&amp;&amp;r&gt;=tr[now].r)&#123;<br><span class="hljs-comment">//如果查到子区间了</span><br>tr[now].sum+=k*(tr[now].r-tr[now].l+<span class="hljs-number">1</span>);<span class="hljs-comment">//先修改这个区间</span><br>tr[now].add+=k;<span class="hljs-comment">//然后给它打上懒标记</span><br><span class="hljs-comment">//注：这里一定要分清顺序，先修改，再标记！</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//如果需要继续向下查询</span><br><span class="hljs-built_in">pushudown</span>(now);<span class="hljs-comment">//一定要先把懒标记向下传</span><br><span class="hljs-type">int</span> mid=(tr[now].l+tr[now].r)/<span class="hljs-number">2</span>;<br><span class="hljs-comment">//这里很像区间查询</span><br><span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">update</span>(now*<span class="hljs-number">2</span>,l,r,k);<br><span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">update</span>(now*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r,k);<br><span class="hljs-comment">//最后别忘了pushup一下</span><br><span class="hljs-built_in">pushup</span>(now);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题2：区间修改，区间查询">例题2：区间修改，区间查询</h3><p><a href="https://www.luogu.com.cn/problem/P3372">洛谷P3372</a></p><p>已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</li><li>求出某区间每一个数的和。</li></ol><p><strong>题目分析</strong></p><p>应用到区间修改，需要注意的一点是，在区间查询时，也需要下传懒标记，这样才能查询到真实的值。</p><p><strong>AC代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> sum;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-type">int</span> add;<span class="hljs-comment">//懒标记</span><br>&#125;tr[N*<span class="hljs-number">4</span>];<span class="hljs-comment">//线段树要开四倍空间哦</span><br><span class="hljs-type">int</span> a[N];<span class="hljs-comment">//原数列</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>tr[x].sum=tr[<span class="hljs-number">2</span>*x].sum+tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//pushup操作</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushudown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(tr[x].add)&#123;<br><span class="hljs-comment">//如果这个节点上有懒标记</span><br>tr[<span class="hljs-number">2</span>*x].add+=tr[x].add,tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].add+=tr[x].add;<br><span class="hljs-comment">//把这个节点的懒标记给他的两个子节点</span><br>tr[<span class="hljs-number">2</span>*x].sum+=tr[x].add*(tr[<span class="hljs-number">2</span>*x].r-tr[<span class="hljs-number">2</span>*x].l+<span class="hljs-number">1</span>);<br>tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].sum+=tr[x].add*(tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].r-tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>);<br><span class="hljs-comment">//分别给它的两个子节点修改</span><br>tr[x].add=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//别忘了清空这个节点的懒标记</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-comment">//建树操作</span><br>tr[x].l=l,tr[x].r=r,tr[x].add=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x].sum=a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*x,l,mid),<span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&lt;=tr[x].l&amp;&amp;r&gt;=tr[x].r) <span class="hljs-keyword">return</span> tr[x].sum;<br><span class="hljs-built_in">pushudown</span>(x);<span class="hljs-comment">//注意，区间查询时也要下懒传标记</span><br><span class="hljs-type">int</span> mid=(tr[x].l+tr[x].r)/<span class="hljs-number">2</span>,sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>,l,r);<br><span class="hljs-keyword">if</span>(r&gt;mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r);<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&lt;=tr[now].l&amp;&amp;r&gt;=tr[now].r)&#123;<br><span class="hljs-comment">//如果查到子区间了</span><br>tr[now].sum+=k*(tr[now].r-tr[now].l+<span class="hljs-number">1</span>);<span class="hljs-comment">//先修改这个区间</span><br>tr[now].add+=k;<span class="hljs-comment">//然后给它打上懒标记</span><br><span class="hljs-comment">//注：这里一定要分清顺序，先修改，再标记！</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//如果需要继续向下查询</span><br><span class="hljs-built_in">pushudown</span>(now);<span class="hljs-comment">//先把懒标记向下传</span><br><span class="hljs-type">int</span> mid=(tr[now].l+tr[now].r)/<span class="hljs-number">2</span>;<br><span class="hljs-comment">//这里很像区间查询</span><br><span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">update</span>(now*<span class="hljs-number">2</span>,l,r,k);<br><span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">update</span>(now*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r,k);<br><span class="hljs-built_in">pushup</span>(now);<span class="hljs-comment">//最后别忘了pushup一下</span><br>&#125;<br>&#125;<br><span class="hljs-type">int</span> n,q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-keyword">while</span>(q--)&#123;<br><span class="hljs-type">int</span> l,r,k,c;<br>cin&gt;&gt;c&gt;&gt;l&gt;&gt;r;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-number">1</span>)&#123;<br>cin&gt;&gt;k;<br><span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,l,r,k);<br>&#125;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,l,r)&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//别忘了开long long哦</span><br></code></pre></td></tr></table></figure><h3 id="例题3：较复杂的区间操作">例题3：较复杂的区间操作</h3><p><a href="https://www.luogu.com.cn/problem/P3373">洛谷P3373</a></p><p>已知一个数列，你需要进行下面三种操作：</p><ol><li><p>将某区间每一个数乘上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>。</p></li><li><p>将某区间每一个数加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>。</p></li><li><p>求出某区间每一个数的和。</p></li></ol><p><strong>题目分析</strong></p><p>有些题要维护多个区间操作，这在<code>pushdown</code>操作上就比较麻烦，比如这道题，要求维护区间加法和区间乘法，所以我们得维护两个懒标记。</p><p>那么我们该怎样安排懒标记的<code>pushdown</code>顺序呢？</p><p>我们考虑先乘后加的维护顺序，假设两个懒标记分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>u</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">mul</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span>，那么这个数值就应该是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>u</mi><mi>l</mi><mo>×</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mul \times sum+add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span>。</p><p>此时如果加上一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span>，就会变成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>u</mi><mi>l</mi><mo>×</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>a</mi><mi>d</mi><mi>d</mi><mo>+</mo><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mul \times sum+add+add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span></p><p>如果乘上一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>u</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">mul</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>那就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>u</mi><mi>l</mi><mo>×</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>×</mo><mi>m</mi><mi>u</mi><mi>l</mi><mo>+</mo><mi>a</mi><mi>d</mi><mi>d</mi><mo>×</mo><mi>m</mi><mi>u</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">mul \times sum \times mul+add \times mul</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span></p><p>这种方式便于计算，如果使用先加后乘的方式，就会比较麻烦甚至会出错。</p><p><strong>AC代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-type">int</span> sum,add,mul;<br>&#125;tr[N*<span class="hljs-number">4</span>];<span class="hljs-comment">//线段树开四倍空间</span><br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n,p,m;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>tr[x].sum=(tr[<span class="hljs-number">2</span>*x].sum+tr[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>].sum)%p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> add,<span class="hljs-type">int</span> mul)</span></span>&#123;<br><span class="hljs-comment">//我们把计算懒标记单独放在这个函数里，否则好多东西挤一块很难看</span><br>tr[x].sum=(tr[x].sum*mul+add*(tr[x].r-tr[x].l+<span class="hljs-number">1</span>))%p;<br>tr[x].mul=(mul*tr[x].mul)%p; <span class="hljs-comment">//先计算乘法懒标记</span><br>tr[x].add=(tr[x].add*mul+add)%p;<span class="hljs-comment">//再算加法懒标记</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">//依次计算两个子节点的值和懒标记</span><br><span class="hljs-built_in">eval</span>(x*<span class="hljs-number">2</span>,tr[x].add,tr[x].mul);<br><span class="hljs-built_in">eval</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,tr[x].add,tr[x].mul);<br>tr[x].add=<span class="hljs-number">0</span>,tr[x].mul=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//清空懒标记，注意：乘法懒标记要初始化成1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>tr[x].l=l,tr[x].r=r;<br>tr[x].add=<span class="hljs-number">0</span>,tr[x].mul=<span class="hljs-number">1</span>;<span class="hljs-comment">//乘法懒标记要初始化成1</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x].sum=a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(x*<span class="hljs-number">2</span>,l,mid),<span class="hljs-built_in">build</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归建树</span><br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> add,<span class="hljs-type">int</span> mul)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&lt;=tr[x].l&amp;&amp;r&gt;=tr[x].r) <span class="hljs-built_in">eval</span>(x,add,mul);<span class="hljs-comment">//计算</span><br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">pushdown</span>(x);<br><span class="hljs-type">int</span> mid=(tr[x].l+tr[x].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">change</span>(x*<span class="hljs-number">2</span>,l,r,add,mul);<br><span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">change</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r,add,mul);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&lt;=tr[x].l&amp;&amp;r&gt;=tr[x].r) <span class="hljs-keyword">return</span> tr[x].sum;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">pushdown</span>(x); <span class="hljs-comment">//区间查询时也要pushdown  </span><br><span class="hljs-type">int</span> mid=(tr[x].l+tr[x].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>,l,r)%p;<br><span class="hljs-keyword">if</span>(r&gt;mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r)%p;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> t,g,c,ch;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-keyword">while</span>(m--)&#123;<br>cin&gt;&gt;ch&gt;&gt;t&gt;&gt;g;<br><span class="hljs-keyword">if</span>(ch==<span class="hljs-number">1</span>)&#123;<br>cin&gt;&gt;c;<br><span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>,t,g,<span class="hljs-number">0</span>,c);          <br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-number">2</span>)&#123;<br>cin&gt;&gt;c;<br><span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>,t,g,c,<span class="hljs-number">1</span>);          <br>&#125;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,t,g)%p&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//记得开longlong</span><br></code></pre></td></tr></table></figure><h3 id="标记永久化">标记永久化</h3><p>其实，维护区间修改的方式有两种，一种是懒标记和标记下传，另一种叫做”标记永久化“。</p><p>标记永久化，就是不下传标记，在每次查询时把经过的标记累加起来，查询时加起来。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/04xkea0k.png" alt="标记永久化"><br>如图，打上标记的节点用绿色表示，查询路线（橙色）经过的就累加。</p><p><strong>标记永久化代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> sum,add;<br><span class="hljs-type">int</span> l,r;<br>&#125;tr[N*<span class="hljs-number">4</span>];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>tr[x].l=l,tr[x].r=r;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x].sum=a[l],tr[x].add=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(x*<span class="hljs-number">2</span>,l,mid),<span class="hljs-built_in">build</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>tr[x].sum=tr[x*<span class="hljs-number">2</span>].sum+tr[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//标记永久化中只有建树时需要用到pushup操作</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>tr[x].sum+=(<span class="hljs-built_in">min</span>(tr[x].r,r)-<span class="hljs-built_in">max</span>(tr[x].l,l)+<span class="hljs-number">1</span>)*k;<span class="hljs-comment">//要取一个交集来加</span><br><span class="hljs-keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;<br>tr[x].add+=k;<span class="hljs-comment">//给节点打上标记后不用下传。</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(tr[x].l+tr[x].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">update</span>(x*<span class="hljs-number">2</span>,l,r,k);<br><span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">update</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r,k);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> add)</span></span>&#123;<br><span class="hljs-keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;<br><span class="hljs-type">int</span> s=(tr[x].r-tr[x].l+<span class="hljs-number">1</span>)*add;<span class="hljs-comment">//查询到节点后给这个区间乘上add</span><br><span class="hljs-keyword">return</span> tr[x].sum+s;<br>&#125;<br>add+=tr[x].add;<span class="hljs-comment">//add代表查询经过的懒标记之和</span><br><span class="hljs-type">int</span> mid=(tr[x].l+tr[x].r)/<span class="hljs-number">2</span>,sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>,l,r,add);<br><span class="hljs-keyword">if</span>(r&gt;mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r,add);<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>标记永久化应用很多，比如可持久化线段树中的区间修改，树套树中第二维的修改。（后面都将讲到）</p><h3 id="习题-2">习题</h3><p>这里给出一些习题，按照难度排序。</p><ol><li><a href="https://www.luogu.com.cn/problem/P2023"> AHOI2009 维护序列</a><br>与例题3差不多</li><li><a href="https://www.luogu.com.cn/problem/P1253">洛谷P1253 扶苏的问题</a><br>稍微复杂的懒标记维护</li><li><a href="https://www.luogu.com.cn/problem/P5142">洛谷P5142 区间方差</a><br>需要一定的数学推导能力</li><li><a href="https://www.luogu.com.cn/problem/P4145">P4145 花神游历各国</a><br>想一想如何优化？</li><li><a href="https://www.luogu.com.cn/problem/P1471">P1471 方差</a><br>3题的加强版，较难</li><li><a href="https://www.luogu.com.cn/problem/P6327">P6327 区间加区间sin和</a><br>需要一些高中的数学知识</li></ol><h1>权值线段树</h1><p>权值线段树是线段树的一种衍生算法，其基本存储结构和线段树基本相同。</p><p>权值线段树与线段树的不同点在于，线段树维护区间信息，权值线段树维护值域信息。</p><p>如图，权值线段树就长这个样子。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/n1w3d47m.png" alt="权值线段树"><br>看起来和线段树没什么区别吧，现在我们插入一个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x8n5ukjg.png" alt="权值线段树插入"><br>每一个包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>的区间都被加上了1。</p><p>那么每个区间维护的到底是什么呢？</p><p>是这个区间内的数的数量。</p><p>当我们依次插入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>4</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{4,1,7,2,8 \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mclose">}</span></span></span></span>后，这个权值线段树就变成了这样。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/htresyd9.png" alt="权值线段树插入"><br>这就是权值线段树的原理。</p><p>权值线段树可以干很多事情，比如查询第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>小，查找前驱后继等。</p><h3 id="插入与删除">插入与删除</h3><p>想一想，我们该如何实现插入一个数的操作呢？</p><p>把从这个数的节点到根节点的路径上每一个节点都加上1即可。</p><p>删除呢？</p><p>减去1就行了。</p><p><strong>代码模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tr[N*<span class="hljs-number">4</span>];<br><span class="hljs-comment">//这就是上文提到过的线段树的另一种写法，因为权值线段树不许要维护区间信息，所以不需要建树的预处理，这种写法就变得很方便。</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>tr[x]=tr[x*<span class="hljs-number">2</span>]+tr[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">//插入一个数k</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-built_in">insert</span>(x*<span class="hljs-number">2</span>,l,mid,k);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">insert</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,k);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">//删除一个数k</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]--;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-built_in">del</span>(x*<span class="hljs-number">2</span>,l,mid,k);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">del</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,k);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span></span>&#123;<br><span class="hljs-comment">//查询ql，qr之间一共有多少个数</span><br><span class="hljs-keyword">if</span>(l&gt;=ql&amp;&amp;r&lt;=qr) <span class="hljs-keyword">return</span> tr[x];<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>,sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ql&lt;=mid) sum=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>,l,mid,ql,qr);<br><span class="hljs-keyword">if</span>(qr&gt;mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,ql,qr);<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题4：权值线段树">例题4：权值线段树</h3><p><a href="https://loj.ac/p/10116">loj 10116</a></p><p>NK 中学组织同学们去五云山寨参加社会实践活动，按惯例要乘坐火车去。由于 NK 中学的学生很多，在火车开之前必须清点好人数。</p><p>初始时，火车上没有学生。当同学们开始上火车时，年级主任从第一节车厢出发走到最后一节车厢，每节车厢随时都有可能有同学上下。年级主任走到第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>节车厢时，他想知道前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>节车厢上一共有多少学生。每次提问，m 总会比前一次大。</p><p><strong>题目分析</strong></p><p>很明显可以用权值线段树做，维护每个区间的数的数量，具体见代码。</p><p><strong>AC代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> tr[N*<span class="hljs-number">4</span>];<span class="hljs-comment">//权值线段树维护的是值域，所以要开n的范围的四倍</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>tr[x]=tr[x*<span class="hljs-number">2</span>]+tr[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]+=p;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-built_in">insert</span>(x*<span class="hljs-number">2</span>,l,mid,k,p);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">insert</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,k,p);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=ql&amp;&amp;r&lt;=qr) <span class="hljs-keyword">return</span> tr[x];<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>,sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ql&lt;=mid) sum=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>,l,mid,ql,qr);<br><span class="hljs-keyword">if</span>(qr&gt;mid) sum+=<span class="hljs-built_in">query</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,ql,qr);<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">while</span>(k--)&#123;<br><span class="hljs-type">char</span> opt;<br><span class="hljs-type">int</span> m,p;<br>cin&gt;&gt;opt;<br><span class="hljs-keyword">if</span>(opt==<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>cin&gt;&gt;m;<br>cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,m)&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-string">&#x27;B&#x27;</span>)&#123;<br><span class="hljs-comment">//上车</span><br>cin&gt;&gt;m&gt;&gt;p;<br><span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,m,p);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//下车</span><br>cin&gt;&gt;m&gt;&gt;p;<br><span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,m,-p);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询第k大数">查询第k大数</h3><p>请注意，这个查询第k大是针对整个权值线段树的，要查区间第k大请去学主席树或树套树。</p><p>权值线段树是维护值域的，一个节点的左右端点都应该是一个具体的数字，而且值域肯定是递增的，所以我们可以二分。</p><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>小于区间中点，那么也就说明结果为左区间第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>大数。否则，也就说明结果为右区间第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><msub><mi>l</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">k−l_{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">ze</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大数。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<span class="hljs-comment">//查到了，返回即可</span><br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=tr[x*<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(x*<span class="hljs-number">2</span>,l,mid,k); <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,k-tr[x*<span class="hljs-number">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询一个数的排名">查询一个数的排名</h3><p>和查询第k大差不多。</p><p>每次把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>与当前区间中点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>比较，如果小于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>，说明在左区间，向左儿子寻找。<br>如果大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>，说明在右区间，这时，它的排名要加上左子树的大小（它比整个左子树的数都大）</p><p>如果找到叶子节点了，那么返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>(在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的区间只有自己，排名第一)</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rnk</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">rnk</span>(x*<span class="hljs-number">2</span>,l,mid,k);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rnk</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,k)+tr[x*<span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题5：用权值线段树实现平衡树">例题5：用权值线段树实现平衡树</h3><p><a href="https://www.luogu.com.cn/problem/P3369">洛谷P3369</a></p><p>实现一个数据结构，来维护一些数，其中需要提供以下操作：</p><ol><li>插入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>数</li><li>删除<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>数(若有多个相同的数，应只删除一个)</li><li>查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>数的排名(排名定义为比当前数小的数的个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span>)</li><li>查询排名为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>的数</li><li>求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>的前驱(前驱定义为小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，且最大的数)</li><li>求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>的后继(后继定义为大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，且最小的数)</li></ol><p><strong>题目分析</strong></p><p>正宗解法自然是平衡树，但是仔细观察这些操作，似乎都可以用权值线段树解决？</p><p>前四个操作我们已经讲解过了，只剩下最后两个：求前驱和后继。</p><p>前驱实际上就是比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>的排名小一位的数，也就是<code>kth(rnk(x)-1)</code>。</p><p>后继就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的排名位置的数，也就是<code>kth(rnk(x+1))</code>。</p><p>那么我们就可以写出代码了？</p><p><strong>没AC代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> tr[<span class="hljs-number">8</span>*N];<span class="hljs-comment">//因为要维护正负区间，所以开二倍，再加线段树的四倍空间，就是八倍</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>tr[x]=tr[x*<span class="hljs-number">2</span>]+tr[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-comment">//若p为1则插入，若p为-1则删除</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]+=p;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-built_in">insert</span>(x*<span class="hljs-number">2</span>,l,mid,k,p);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">insert</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,k,p);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">//查询排名为k的数</span><br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=tr[x*<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(x*<span class="hljs-number">2</span>,l,mid,k); <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,k-tr[x*<span class="hljs-number">2</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rnk</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">//查找数k的排名</span><br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">rnk</span>(x*<span class="hljs-number">2</span>,l,mid,k);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rnk</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,k)+tr[x*<span class="hljs-number">2</span>];<br>&#125;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">while</span>(n--)&#123;<br><span class="hljs-type">int</span> opt,x;<br>cin&gt;&gt;opt&gt;&gt;x;<br><span class="hljs-keyword">switch</span>(opt)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,-N,N,x,<span class="hljs-number">1</span>);<span class="hljs-comment">//插入</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,-N,N,x,<span class="hljs-number">-1</span>);<span class="hljs-comment">//删除</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>cout&lt;&lt;<span class="hljs-built_in">rnk</span>(<span class="hljs-number">1</span>,-N,N,x)&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>cout&lt;&lt;<span class="hljs-built_in">kth</span>(<span class="hljs-number">1</span>,-N,N,x)&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>cout&lt;&lt;<span class="hljs-built_in">kth</span>(<span class="hljs-number">1</span>,-N,N,<span class="hljs-built_in">rnk</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,N,x)<span class="hljs-number">-1</span>)&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>cout&lt;&lt;<span class="hljs-built_in">kth</span>(<span class="hljs-number">1</span>,-N,N,<span class="hljs-built_in">rnk</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,N,x)+<span class="hljs-number">1</span>)&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>细心的你会发现，这个线段树怎么开了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">8\times10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>呢？肯定会爆空间啊。</p><p>但是题目要求的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">|x|\le10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>却令我们不得不开这么大。</p><p>怎么办呢？</p><p>一般来说，优化线段树空间的有两种方法。</p><p>一种是离散化后再进行操作（离线），一种是动态开点。</p><p>（这两种方法都会在下一节介绍到）</p><p>在这道题中，我们可以使用动态开点的方式，优化空间。</p><p><strong>‘动态开点代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">10</span>,M=<span class="hljs-number">4e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> tr[M];<br><span class="hljs-type">int</span> ls[M],rs[M],tot=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>tr[x]=tr[ls[x]]+tr[rs[x]];<span class="hljs-comment">//动态开点后，就不能用x*2的方式存了，得开lsrs两个数组（或结构体）</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> p)</span></span>&#123;<span class="hljs-comment">//x是引用形式，方便传值</span><br><span class="hljs-keyword">if</span>(!x) x=++tot;<span class="hljs-comment">//动态开点</span><br><span class="hljs-comment">//若p为1则插入，若p为-1则删除</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]+=p;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-built_in">insert</span>(ls[x],l,mid,k,p);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">insert</span>(rs[x],mid+<span class="hljs-number">1</span>,r,k,p);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<span class="hljs-comment">//查到了，返回即可</span><br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=tr[ls[x]]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(ls[x],l,mid,k); <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(rs[x],mid+<span class="hljs-number">1</span>,r,k-tr[ls[x]]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rnk</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">rnk</span>(ls[x],l,mid,k);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rnk</span>(rs[x],mid+<span class="hljs-number">1</span>,r,k)+tr[ls[x]];<br>&#125;<br><span class="hljs-type">int</span> n,root;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">while</span>(n--)&#123;<br><span class="hljs-type">int</span> opt,x;<br>cin&gt;&gt;opt&gt;&gt;x;<br><span class="hljs-keyword">switch</span>(opt)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-built_in">insert</span>(root,-N,N,x,<span class="hljs-number">1</span>);<span class="hljs-comment">//因为动态开点的插入写成引用形式，所以需要带进去一个变量</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">insert</span>(root,-N,N,x,<span class="hljs-number">-1</span>);<span class="hljs-comment">//删除</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>cout&lt;&lt;<span class="hljs-built_in">rnk</span>(root,-N,N,x)&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>cout&lt;&lt;<span class="hljs-built_in">kth</span>(root,-N,N,x)&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>cout&lt;&lt;<span class="hljs-built_in">kth</span>(root,-N,N,<span class="hljs-built_in">rnk</span>(root,-N,N,x)<span class="hljs-number">-1</span>)&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>cout&lt;&lt;<span class="hljs-built_in">kth</span>(root,-N,N,<span class="hljs-built_in">rnk</span>(root,-N,N,x+<span class="hljs-number">1</span>))&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想学习离散化的解法，可以看这位%%%的<a href="https://www.luogu.com.cn/blog/olinr/quan-zhi-xian-duan-shu">博客</a>。</p><h2 id="空间优化技巧">空间优化技巧</h2><p>这里介绍两种优化方式：离散化和动态开点。</p><p>两种方法其实各有优劣，如果只是为了缩小值域，离散化似乎更好写一点，但是动态开点还可以被应用到可持久化、线段树合并和分裂上，所以都学一学吧。</p><h3 id="离散化">离散化</h3><p>数据范围太大了，需要缩小数据范围，这句话让你想到了什么？</p><p>当然是离散化了！</p><p>所以我们可以把所有操作都存起来，排序然后离散化，离线进行操作。</p><p>如果你不会离散化，请看这篇<a href="https://www.luogu.com.cn/blog/luhaoren/Discretization">博客</a>。</p><h3 id="动态开点">动态开点</h3><p>动态开点，顾名思义，就是使用的时候再开点。</p><p>如果数据范围是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-10^7,10^7]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，在权值线段树的使用过程中，很大一部分的节点会使用不到，这会造成一种浪费。</p><p>动态开点的意思就是：不一上来就把所有的节点全部建立起来，只在需要用到一个节点的时候再建立一个节点。</p><p>注意：使用动态开点线段树的话，节点的下标将是无序的，因此必须建立结构体或用两个数组来分别保存一个节点的左右子节点。</p><p><strong>代码模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tr[M];<br><span class="hljs-type">int</span> ls[M],rs[M],tot=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>tr[x]=tr[ls[x]]+tr[rs[x]];<span class="hljs-comment">//动态开点后，就不能用x*2的方式存了，得开lsrs两个数组（或结构体）</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//x是引用形式，方便传值</span><br><span class="hljs-keyword">if</span>(!x) x=++tot;<span class="hljs-comment">//动态开点</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-built_in">insert</span>(ls[x],l,mid,k);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">insert</span>(rs[x],mid+<span class="hljs-number">1</span>,r,k);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="习题-3">习题</h3><p>提供几道权值线段树的习题。</p><ol><li><a href="https://loj.ac/p/10114">loj10114.数星星 Stars</a><br>权值线段树，需要用动态开点或离散化的优化</li><li><a href="https://www.luogu.com.cn/problem/P1168">P1168 中位数</a><br>离散化，然后开权值线段树维护</li><li><a href="https://www.luogu.com.cn/problem/P2073">P2073 送花</a><br>可以用权值线段树做</li><li><a href="https://www.luogu.com.cn/problem/P3313">SDOI2014 旅行</a><br>树链剖分（如果你会的话），用动态开点维护</li></ol><h1>zkw线段树</h1><p>zkw线段树是一种用循环实现的线段树，比正常的递归式线段树快很多，而且好写。</p><h2 id="zkw线段树的引入">zkw线段树的引入</h2><p>我们观察一个线段树的结构，按照堆式储存，叶子节点的序号是连续的。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5d2oqt4e.png" alt="线段树的结构"><br>而原数组中的数字编号也恰恰是连续的，所以二者之间有一个对应关系。</p><p>仔细观察，发现两者序号之差竟然是一个定值。</p><p>所以，我们就可以快速地找到数字在线段树中的位置，即<code>x+N</code>（N为差值）。</p><p>而这个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>就应该是线段树中抛去叶子节点之外的节点的数量。</p><p>为了方便，我们约定，无论树有没有那么大，我们都把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>看作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，无数据的叶节点空置即可。</p><p>这样我们就可以通过循环的方式，完成线段树的初始化。</p><p><strong>建树代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tr[N*<span class="hljs-number">4</span>];<span class="hljs-comment">//zkw线段树不用维护子区间，直接开数组就行</span><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++) cin&gt;&gt;tr[i];<span class="hljs-comment">//直接读入到叶子节点里</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--) tr[i]=tr[i*<span class="hljs-number">2</span>]+tr[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<span class="hljs-comment">//自底向上更新</span><br>&#125;<br></code></pre></td></tr></table></figure><p>建树才三行代码，还包括了读入，zkw线段树是不是很神奇？</p><h2 id="单点修改-区间查询">单点修改&amp;区间查询</h2><h3 id="单点修改-2">单点修改</h3><p>找到了数字在线段树中的位置，怎么更新它的父节点呢？</p><p>按照堆式储存的特点，节点的父节点就应该是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/2</span></span></span></span>（x是这个节点）</p><p>那么从叶子节点开始，一步步地向上爬，更新，就完成了一次单点修改。</p><p>这也是zkw线段树的一个特色——自底向上。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/cqcc4wbb.png" alt="zkw线段树单点修改"><br><strong>单点修改代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//给x加上k</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x+=n;i;i/=<span class="hljs-number">2</span>) tr[i]+=k;<span class="hljs-comment">//自底向上更新</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看完单点修改，相信大家已经会了单点查询，那就是：</p><p><strong>单点查询代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query_one</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//查询x值</span><br><span class="hljs-keyword">return</span> tr[x+n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间查询-2">区间查询</h3><p>接下来思考，如何做到区间查询呢？</p><p>如图，以查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>区间之和为例，我们先设两个指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>q</mi><mo>=</mo><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p=l-1,q=r+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/y4rn7z1g.png" alt="zkw线段树区间查询"></p><p>然后让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>一直往上跳，直到两个指针的父节点相同。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/uweagdjo.png" alt="zkw线段树区间查询"><br>有没有发现，这两个指针笼罩的地方，就是我们要查询的区间。</p><p>多观察一会，我们会发现一个规律：</p><ol><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>指向的节点是左儿子，那么答案加上右儿子的值</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>指向的节点是右儿子，那么答案加上左儿子的值</p></li></ol><p><strong>区间查询代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=l<span class="hljs-number">-1</span>,q=r+<span class="hljs-number">1</span>;p/<span class="hljs-number">2</span>!=q/<span class="hljs-number">2</span>;p/=<span class="hljs-number">2</span>,q/=<span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">if</span>(!(p%<span class="hljs-number">2</span>)) ans+=tr[p+<span class="hljs-number">1</span>];<span class="hljs-comment">//第一种情况</span><br><span class="hljs-keyword">if</span>(q%<span class="hljs-number">2</span>) ans+=tr[q<span class="hljs-number">-1</span>];<span class="hljs-comment">//第二种情况</span><br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="习题-4">习题</h3><ol><li><a href="https://www.luogu.com.cn/problem/P3374">P3374 单点修改，区间查询</a>  用zkw线段树再做一遍</li></ol><h2 id="区间修改-单点查询">区间修改&amp;单点查询</h2><h3 id="区间修改-2">区间修改</h3><p>zkw线段树也支持区间修改，但是由于很难做到<code>pushdown</code>，所以zkw线段树采用标记永久化的方式进行区间修改。</p><p>区间修改和区间查询差不多，也是维护两个指针，不同点是：从累加答案变成修改懒标记。</p><p><strong>区间修改代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">uplate</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//给l,r区间内的数加上k</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=l<span class="hljs-number">-1</span>,q=r+<span class="hljs-number">1</span>;p/<span class="hljs-number">2</span>!=q/<span class="hljs-number">2</span>;p/=<span class="hljs-number">2</span>,q/=<span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">if</span>(!(p%<span class="hljs-number">2</span>)) add[p+<span class="hljs-number">1</span>]+=k;<br><span class="hljs-keyword">if</span>(q%<span class="hljs-number">2</span>) add[q<span class="hljs-number">-1</span>]+=k;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单点查询">单点查询</h3><p>在有懒标记的情况下，单点查询也变得不同。</p><p>首先自底向上累加所有祖宗节点的懒标记，然后再加上本身的值。</p><p><strong>单点查询代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query_one</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//查询x值</span><br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x+=n;i;i/=<span class="hljs-number">2</span>) sum+=add[i];<br><span class="hljs-keyword">return</span> tr[x+n]+add[i];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="习题-5">习题</h3><ol><li><a href="https://www.luogu.com.cn/problem/P3372">P3372 线段树1</a><br>用zkw线段树做一遍</li><li><a href="https://www.luogu.com.cn/problem/P3368">P3368 树状数组2</a><br>区间修改，单点查询</li></ol><h1>可持久化线段树</h1><p>可持久化线段树 ，顾名思义，就是可以保留每一个历史版本，并且支持在历史版本上进行操作的线段树。</p><p>为什么要可持久化呢?有的时候离线维护扫描线之类的东西时，就需要在时间轴里穿梭，这就需要历史版本；权值线段树如果能可持久化，就可以维护区间的数据，达到静态树套树的效果。</p><p>那么如何可持久化呢？</p><p>首先，最暴力的做法就是，开<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个线段树，但是这样肯定会爆空间，所以，我们得想点别的招。</p><p>如图，这是一个普通的线段树。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/fe4y9km7.png" alt=""><br>我们把第7个数加上3，如图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/us4k8mk9.png" alt=""></p><p>仔细观察，就会发现，被修改的节点实际上只是一条链，长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>于是，著名神犇hjt突发奇想，如果每次修改只维护一条链的话，空间复杂度就变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>了呀。</p><p>于是就有了可持久化线段树，也叫主席树（能猜到原因吧）</p><p>如图，在可持久化线段树里给第7个数加上3。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/y92xtz16.png" alt=""><br>从这个图中，我们可以看出可持久化线段树的诀窍在于——复用历史版本的节点。</p><p>可持久化线段树只会增加需要修改的节点，而不需要修改的节点就可以使用以前的结构，这种思想被称为“函数式编程“，所以可持久化线段树也叫”函数式线段树“。</p><p><strong>核心代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-comment">//建树操作，即第0个版本，所有版本复用的基础</span><br>x=++tot;<span class="hljs-comment">//可持久化线段树使用动态开点的方式，因此需要有lsrs数组存储左右儿子节点</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]=a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(ls[x],l,mid),<span class="hljs-built_in">build</span>(rs[x],mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-comment">//因为x是引用形式，所以会直接给lsrs数组赋值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> p)</span></span>&#123;<br>x=++tot;<br>tr[x]=tr[u],ls[x]=ls[u],rs[x]=rs[u];<br><span class="hljs-comment">//复制原节点</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]=p;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-built_in">change</span>(ls[u],ls[x],l,mid,k,p);<span class="hljs-comment">//修改左儿子，右儿子直接复用原节点的右儿子</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(rs[u],rs[x],mid+<span class="hljs-number">1</span>,r,k,p);<span class="hljs-comment">//同理</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题6：可持久化数组">例题6：可持久化数组</h3><p><a href="https://www.luogu.com.cn/problem/P3919">洛谷P3919</a></p><p>维护这样的一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的数组，支持如下几种操作：</p><ol><li>在某个历史版本上修改某一个位置上的值</li><li>访问某个历史版本上的某一位置的值</li></ol><p>此外，每进行一次操作（对于操作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>开始编号，版本<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>表示初始状态数组）</p><p><strong>题目分析</strong></p><p>很明显，这一个可持久化线段树模板题，需要单点修改，单点查询，套用模板即可。</p><p><strong>AC代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>,M=<span class="hljs-number">5e7</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//可持久化线段树大概需要O(4n+mlogn)的空间，一般直接开N&lt;&lt;5</span><br><span class="hljs-type">int</span> tr[M],root[N],ls[M],rs[M],tot=<span class="hljs-number">0</span>,a[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>x=++tot;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]=a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(ls[x],l,mid),<span class="hljs-built_in">build</span>(rs[x],mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> p)</span></span>&#123;<br>x=++tot;<span class="hljs-comment">//动态开点</span><br>tr[x]=tr[u],ls[x]=ls[u],rs[x]=rs[u];<span class="hljs-comment">//复制节点</span><br><span class="hljs-keyword">if</span>(l==r)&#123;<br>tr[x]=p;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-built_in">change</span>(ls[u],ls[x],l,mid,k,p);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(rs[u],rs[x],mid+<span class="hljs-number">1</span>,r,k,p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> tr[x];<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[x],l,mid,k);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[x],mid+<span class="hljs-number">1</span>,r,k);<br>&#125;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-comment">//本题稍微有点卡常，需要用printf和scanf</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-built_in">build</span>(root[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>,n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> v,opt,k,p;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;v,&amp;opt);<br><span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;k,&amp;p);<br><span class="hljs-built_in">change</span>(root[v],root[i],<span class="hljs-number">1</span>,n,k,p);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">query</span>(root[v],<span class="hljs-number">1</span>,n,k));<br>root[i]=root[v];<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题7：静态区间第k小">例题7：静态区间第k小</h3><p><a href="https://www.luogu.com.cn/problem/P3834">洛谷P3834</a></p><p>给定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数构成的序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>，将对于指定的闭区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 查询其区间内的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小值。</p><p><strong>题目分析</strong></p><p>如果没有区间操作，查询第k小可以用权值线段树实现，如果有要支持区间操作呢？</p><p>我们建一颗可持久化权值线段树，如图，把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{2,4,1,3\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">}</span></span></span></span>这个数列的数依次插入。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hyz1t3el.png" alt=""><br>仔细观察，就会发现第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>棵树保存着前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>个数的信息（设初始化的树为第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>棵）</p><p>也就是说，这个可持久化线段树可以说是数列的“前缀树”。</p><p>你能想到什么？</p><p>可持久化线段树满足区间可加减性，所以我们可以用前缀和的方式找出维护<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>个数的信息的树。</p><p>也就是拿出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>棵树和第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>棵树，两者相减，结果就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的信息。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ibfu7ul5.png" alt=""><br>而在相减后的树上找第k小相信大家都已经会了。</p><p>那么就可以写出代码了！</p><p>注：这题数据很水，题面给<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">|a_i |\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，但实际上的数据范围是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">0 \le a_i \le 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，甚至不需要离散化的优化，就可以过。</p><p><strong>AC代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> tr[N&lt;&lt;<span class="hljs-number">5</span>],ls[N&lt;&lt;<span class="hljs-number">5</span>],rs[N&lt;&lt;<span class="hljs-number">5</span>],root[N],tot=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">//建树</span><br>x=++tot;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(ls[x],l,mid),<span class="hljs-built_in">build</span>(rs[x],mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>x=++tot;<span class="hljs-comment">//动态开点</span><br>tr[x]=tr[u]+<span class="hljs-number">1</span>,ls[x]=ls[u],rs[x]=rs[u];<span class="hljs-comment">//复制该节点的所有信息（可以直接在节点上+1，否则还得pushuo一遍）</span><br><span class="hljs-keyword">if</span>(l==r)  <span class="hljs-keyword">return</span>; <br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-built_in">insert</span>(ls[u],ls[x],l,mid,k);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">insert</span>(rs[u],rs[x],mid+<span class="hljs-number">1</span>,r,k);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>,lx=tr[ls[v]]-tr[ls[u]];<span class="hljs-comment">//两颗树信息相减得到的左儿子信息</span><br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<span class="hljs-comment">//如果只有一个数，第几大都是这个数了，直接返回</span><br><span class="hljs-keyword">if</span>(k&lt;=lx) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[u],ls[v],l,mid,k);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[u],rs[v],mid+<span class="hljs-number">1</span>,r,k-lx);<span class="hljs-comment">//二分查找第k小</span><br>&#125;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">build</span>(root[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>,<span class="hljs-number">1e6</span>);<span class="hljs-comment">//建树</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-type">int</span> t;<br>cin&gt;&gt;t;<br><span class="hljs-built_in">insert</span>(root[i<span class="hljs-number">-1</span>],root[i],<span class="hljs-number">0</span>,<span class="hljs-number">1e6</span>,t);<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> l,r,k;<br>cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;<br>cout&lt;&lt;<span class="hljs-built_in">query</span>(root[l<span class="hljs-number">-1</span>],root[r],<span class="hljs-number">0</span>,<span class="hljs-number">1e6</span>,k)&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，这份代码在除了洛谷以外的其它OJ上是AC不了的，因为题面上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">|a_i|\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>的数据范围使代码必须要有离散化的优化，这里给出优化代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//其他部分和前面无异，这以后是离散化代码</span><br><span class="hljs-type">int</span> n,m,tt=<span class="hljs-number">0</span>;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;mp;<span class="hljs-comment">//使用map离散化，使用sort离散化也可以</span><br><span class="hljs-type">int</span> val[N],a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">build</span>(root[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        mp[a[i]]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:mp)&#123;<br>    <span class="hljs-comment">//map会自己排序，在遍历的过程中标上映射后的序号</span><br>        mp[it.first]=++tt;<br>        val[tt]=it.first;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(root[i<span class="hljs-number">-1</span>],root[i],<span class="hljs-number">1</span>,n,mp[a[i]]);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l,r,k;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;<br>        cout&lt;&lt;val[<span class="hljs-built_in">query</span>(root[l<span class="hljs-number">-1</span>],root[r],<span class="hljs-number">1</span>,n,k)]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="习题-6">习题</h3><ol><li><a href="https://www.luogu.com.cn/problem/P3402">洛谷P3402 可持久化并查集</a><br>注意并查集的合并操作</li><li><a href="https://www.luogu.com.cn/problem/P3567">[POI2014] KUR-Couriers</a><br>维护区间绝对众数，有乱搞做法</li></ol><h1>U.P.D</h1><p>2023年2月17日 初稿，大概两千多字。</p><p>2023年6月？ cry拿去学，发现了一堆错误（比如代码写了个<code>tr[x]=tr[x*2]+tr[x*2]</code>）。</p><p>2023年7月3日 开始重写。</p><p>2023年7月6日 写完基础部分</p><p>2023年7月8日 增加了权值线段树</p><p>2023年7月9日 挪到了洛谷上，把图片传到了洛谷图床上。增加了权值线段树的习题。</p><p>2023年7月9日 增加了zkw线段树</p><p>2023年7月11日 增加了可持久化线段树</p><h1>参考资料</h1><ol><li><p><a href="https://oi-wiki.org/ds/seg/">oiwiki关于线段树储存空间的证明</a></p></li><li><p><a href="https://www.luogu.com.cn/blog/pks-LOVING/senior-data-structure-qian-tan-xian-duan-shu-segment-tree">洛谷日报·线段树</a></p></li><li><p><a href="https://www.cnblogs.com/ycx-akioi/p/Eternal-tag.html">标记永久化</a></p></li><li><p><a href="https://www.luogu.com.cn/blog/IdanSuce/line-segment-tree">标记永久化</a></p></li><li><p><a href="https://www.luogu.com.cn/blog/your-alpha1022/WeightSegmentTree-ChairmanTree">洛谷日报·权值线段树到主席树</a></p></li><li><p><a href="https://www.luogu.com.cn/blog/your-alpha1022/WeightSegmentTree-ChairmanTree">P3369普通平衡树题解</a></p></li><li><p><a href="https://wenku.baidu.com/view/dd73fe22102de2bd97058810?aggId=3a599dd411661ed9ad51f01dc281e53a59025108&amp;fr=catalogMain_text_ernie_recall_backup_new%3Awk_recommend_main3&amp;_wkts_=1688890056669">统计的力量（zkw课件）</a></p></li><li><p><a href="https://www.luogu.com.cn/blog/egfyufg/post-suan-fa-xian-duan-shu">同机房巨佬的博客</a></p></li><li><p><a href="https://www.luogu.com.cn/blog/82152/Introduction-of-zkwSegmentTree">洛谷日报·zkw线段树</a></p></li><li><p><a href="https://wenku.baidu.com/view/dd73fe22102de2bd97058810?aggId=3a599dd411661ed9ad51f01dc281e53a59025108&amp;fr=catalogMain_text_ernie_recall_backup_new%3Awk_recommend_main3&amp;_wkts_=1688890056669">zkw的课件</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记】搜索基础</title>
    <link href="/2023/02/09/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E6%90%9C%E7%B4%A2%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/02/09/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E6%90%9C%E7%B4%A2%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>有了个人网站后，我翻了翻以前写的算法博客，找到了一堆……不知怎么形容的文章，只好挑了几个写的还算可以的放上去。</p><h1>1 深度优先搜索</h1><p>深度优先搜索一种搜索算法，英文缩写为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">FS</span></span></span></span>，即Depth First Search其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。「1」</p><p>简单来说，深搜就是“一条路走到黑”。</p><h2 id="1-1-深度优先搜索的顺序">1.1 深度优先搜索的顺序</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9ry7rds5.png" alt=""></p><p>(手绘图片，有点简陋请不要介意）</p><p>步骤：</p><ol><li><p>首先找到初始节点1。</p></li><li><p>依此从1未被访问的邻接点出发，对图进行深度优先遍历。</p></li><li><p>若有节点未被访问，则回溯到该节点，继续进行深度优先遍历。</p></li><li><p>直到所有与顶点1路径相通的节点都被访问过一次。</p></li></ol><h2 id="1-2-DFS模板">1.2 DFS模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*到达目标位置*/</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*枚举所有可能性*/</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*符合条件*/</span>)&#123;<br>            <span class="hljs-comment">//标记</span><br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-comment">/*下一个位置*/</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-例题">1.3 例题</h2><p><strong>洛谷P1706</strong></p><p><strong>全排列问题</strong><br><img src="https://cdn.luogu.com.cn/upload/image_hosting/87eggnv1.png" alt=""></p><h3 id="解法：">解法：</h3><ol><li><p><code>next_permutation</code>函数（stl字典序全排列函数）</p></li><li><p>暴力枚举</p></li><li><p>DFS搜索</p></li></ol><h4 id="解法1">解法1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//代码来自@shajjl大佬</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n,i,j=<span class="hljs-number">1</span>,k;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> &#123;a[i]=n-i+<span class="hljs-number">1</span>;j*=i;&#125;<span class="hljs-comment">//题目好像没说要从小到大输出</span><br>     <span class="hljs-comment">//但保险起见还是初始赋值为最大序列</span><br>     <span class="hljs-comment">//即a[1~n]=n~1;顺便计算n!</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=j;i++)<br> &#123;<span class="hljs-built_in">next_permutation</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>   cout&lt;&lt;<span class="hljs-string">&quot;    &quot;</span>&lt;&lt;a[k];<span class="hljs-comment">//排一次输出一次</span><br>       <span class="hljs-comment">//空格建议复制</span><br>  cout&lt;&lt;endl;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解法2">解法2</h4><p>暴力枚举就需要循环n次，而题目中n限定在9以内，这就需要写9个循环，但是那太多啦，所以作者就写了3个循环，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;a&lt;=n;a++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=<span class="hljs-number">1</span>;b&lt;=n;b++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;c&lt;=n;c++)&#123;<br>    <span class="hljs-keyword">if</span>(a!=b&amp;&amp;b!=c&amp;&amp;a!=c) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d%5d%5d\n&quot;</span>,a,b,c);<br>    &#125;<br>    &#125;<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解法3">解法3</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,vis[<span class="hljs-number">100</span>],a[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//输出函数</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>,a[i]);<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">//k代表搜索到了第k格</span><br>    <span class="hljs-keyword">if</span>(k==n)&#123;<br><span class="hljs-comment">//填满了的时候</span><br>        <span class="hljs-built_in">print</span>();<span class="hljs-comment">//输出</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//1-n循环填数</span><br>        <span class="hljs-keyword">if</span>(!vis[i])&#123;<br><span class="hljs-comment">//如果当前数没有用过</span><br>            vis[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//那么就标记</span><br>            a[k+<span class="hljs-number">1</span>]=i;<span class="hljs-comment">//加入数组</span><br>            <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<span class="hljs-comment">//搜索下一个</span><br>            vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//开始搜索</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度">时间复杂度</h3><h4 id="解法1-2">解法1</h4><p>通过bdfs，我们知道，<code>next_permutation</code>函数的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，再观察程序，程序内有两重循环，所以，这个程序的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="解法2-2">解法2</h4><p>暴力枚举n重循环，很明显，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="解法3-2">解法3</h4><p>n个不相同的数字的全排列有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span>个，在递归的过程中，这个时间复杂度大概在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">!)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!)</span></span></span></span>之间。</p><h4 id="分析">分析</h4><p>所以，dfs的解法明显比暴力枚举更优。</p><h1>2 广度优先搜索</h1><p>广度优先搜索（Breadth First Search）简称广搜、宽搜或者 BFS。</p><p>如果说深搜是“一条路走到黑”，那么广搜就是一层一层地搜索。</p><p>那么如何实现这个过程呢？我们就需要用一个数据结构——队列。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7owuzrzf.png" alt=""></p><h2 id="广搜的搜索顺序">广搜的搜索顺序</h2><ol><li><p>首先找到初始节点1，把它加入队列。</p></li><li><p>取出队首，依此访问该节点未访问过的的邻接点，把他们加入队列。</p></li><li><p>重复执行步骤2，直到队列为空。</p></li></ol><h2 id="广搜模板代码">广搜模板代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v<span class="hljs-comment">/*开始节点*/</span>)</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;q;<span class="hljs-comment">//队列</span><br>    q.<span class="hljs-built_in">push</span>(v);<span class="hljs-comment">//把开始节点加入队列</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-comment">//BFS是用循环实现的</span><br>        <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//取队首</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*达到目标条件*/</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//队首出队</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*枚举可能性*/</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*符合条件*/</span>) q.<span class="hljs-built_in">push</span>(<span class="hljs-comment">/*该元素*/</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//没有搜索到</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="例题">例题</h2><p>U263917 抓住拿头牛</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6dvlxu3z.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;PLL;<span class="hljs-comment">//first代表位置，second代表步数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> vis[N]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//是否访问过</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;PLL&gt;q;<span class="hljs-comment">//队列</span><br>q.<span class="hljs-built_in">push</span>(&#123;n,<span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//加入队首</span><br>vis[n]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>PLL head=q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//取出队首</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//队首出队</span><br><span class="hljs-type">int</span> f=head.first,s=head.second;<br><span class="hljs-keyword">if</span>(f==k) <span class="hljs-keyword">return</span> s; <span class="hljs-comment">//达到目标就结束</span><br>        <span class="hljs-keyword">if</span>(f+<span class="hljs-number">1</span>&lt;N&amp;&amp;vis[f+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//从x移动到x+1</span><br>    vis[f+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>(&#123;f+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>&#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(f*<span class="hljs-number">2</span>&lt;N&amp;&amp;vis[f*<span class="hljs-number">2</span>]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//从x移动到x*2</span><br>            vis[f*<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>(&#123;f*<span class="hljs-number">2</span>,s+<span class="hljs-number">1</span>&#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(f<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;vis[f<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//从x移动到x-1</span><br>            vis[f<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>(&#123;f<span class="hljs-number">-1</span>,s+<span class="hljs-number">1</span>&#125;);<br>        &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br>cout&lt;&lt;<span class="hljs-built_in">bfs</span>();<span class="hljs-comment">//开始搜索</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>3 搜索之连通性</h1><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>d</mi><mi>f</mi><mi>i</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Floodfill</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Fl</span><span class="mord mathnormal">oo</span><span class="mord mathnormal" style="margin-right:0.10764em;">df</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span></span></span>又名<strong>泛洪填充算法</strong>，类似于画图的油漆桶工具一样，我们把所有起点能走到的格子全部拿一个颜色标记一下，然后如果终点没有被标记就说明不能联通。</p><p>因为所有能走到的点都需要遍历一遍，并且不重复走同一个点，时间复杂度为<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mtext>格子个数</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(格子个数)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord cjk_fallback">格子个数</span><span class="mclose">)</span></span></span></span>  的。</p><p>可以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">BFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">BFS</span></span></span></span>也可以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">FS</span></span></span></span>搜实现，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">BFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">BFS</span></span></span></span>可以顺便求出来最短距离，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">FS</span></span></span></span>又省空间又好写，如果不求距离一般拿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">FS</span></span></span></span>实现。</p><h2 id="例题-1">例题#1</h2><p>POJ 1818 红与黑<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/rk5k7imd.png" alt=""></p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//四个方向的数值，为了方便用两个数组存</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> n,m,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//dfs搜索</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>   <span class="hljs-type">int</span> xx=dx[i]+x,yy=dy[i]+y;<br>   <span class="hljs-keyword">if</span>(a[x][y]!=<span class="hljs-string">&#x27;#&#x27;</span>&amp;&amp;x&gt;=<span class="hljs-number">1</span>&amp;&amp;y&gt;=<span class="hljs-number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&lt;=m)&#123;<br>        cnt++;<br>            a[xx][yy]=<span class="hljs-string">&#x27;#&#x27;</span>;<span class="hljs-comment">//</span><br>            <span class="hljs-built_in">dfs</span>(xx,yy);<br>    &#125;<br>   &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-type">int</span> xx,yy;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>cin&gt;&gt;a[i][j];<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;@&#x27;</span>) xx=i,yy=j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(xx,yy);<br>cout&lt;&lt;cnt;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>   <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】一本通最小生成树·新的开始</title>
    <link href="/2023/02/07/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E4%B8%80%E6%9C%AC%E9%80%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%C2%B7%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <url>/2023/02/07/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E4%B8%80%E6%9C%AC%E9%80%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%C2%B7%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h1>原题</h1><p>发展采矿业当然首先得有矿井， 小FF花了上次探险获得的千分之一的财富请人在岛上挖了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>口矿井， 但他似乎忘记考虑的矿井供电问题…… 为了保证电力的供应， 小FF想到了两种办法：</p><ol><li>在这一口矿井上建立一个发电站，费用为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>（发电站的输出功率可以供给任意多个矿井）。</li><li>将这口矿井与另外的已经有电力供应的矿井之间建立电网， 费用为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>。小FF希望身为”NewBe_One&quot; 计划首席工程师的你帮他想出一个保证所有矿井电力供应的最小花费。</li></ol><h2 id="输入">输入</h2><p>第一行一个整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>， 表示矿井总数。</p><p>第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>～<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>行，每行一个整数， 第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">v[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>表示在第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>口矿井上建立发电站的费用。</p><p>接下来为一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>的矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p[ i , j ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示在第i口矿井和第j口矿井之间建立电网的费用（数据保证有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p[ i, j ] = p[ j, i ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>, 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p[ i, i ]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）。</p><h2 id="输出">输出</h2><p>仅一个整数， 表示让所有矿井获得充足电能的最小花费。</p><h2 id="样例输入">样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br><span class="hljs-number">4</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="样例输出">样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>无</p><h1>题目大意</h1><p>最小生成树。唯一的难点是如何表示发电站，后来想到可以把一个点有发电站看成这个点和0点的连线。然后跑一遍<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">kruskall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">ka</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span></span></span>就A了。</p><h1>算法</h1><p>最小生成树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">kruskall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">ka</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span></span></span>算法</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">1010</span>];<span class="hljs-comment">//并查集函数</span><br><span class="hljs-type">int</span> n,sum=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">//并查集查询操作</span><br><span class="hljs-keyword">if</span>(a[x]==x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> a[x]=<span class="hljs-built_in">find</span>(a[x]);<span class="hljs-comment">//路径压缩</span><br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> a,b,w;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.w&lt;b.w;<span class="hljs-comment">//自定义排序，也可以重载运算符</span><br>&#125;<br>vector&lt;node&gt;e;<span class="hljs-comment">//边</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>a[i]=i;<span class="hljs-comment">//并查集初始化</span><br><span class="hljs-type">int</span> p;<br>cin&gt;&gt;p;<br>e.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>,i,p&#125;);<span class="hljs-comment">//把发电站看成和0点的连线</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br><span class="hljs-type">int</span> t;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">if</span>(i&gt;=j) <span class="hljs-keyword">continue</span>;<br>e.<span class="hljs-built_in">push_back</span>(&#123;i,j,t&#125;);<span class="hljs-comment">//普通的边</span><br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(e.<span class="hljs-built_in">begin</span>(),e.<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-comment">//排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:e)&#123;<br><span class="hljs-comment">//kruskall算法</span><br><span class="hljs-type">int</span> fa=<span class="hljs-built_in">find</span>(it.a),fb=<span class="hljs-built_in">find</span>(it.b);<br><span class="hljs-keyword">if</span>(fa!=fb)&#123;<br>a[fa]=fb;<br>sum+=it.w;<span class="hljs-comment">//累加权值</span><br>&#125;<br>&#125;<br>cout&lt;&lt;sum;<span class="hljs-comment">//输出</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>感谢观看<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">qwq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">qwq</span></span></span></span>！</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>一本通</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】一本通最小生成树·北极通讯网络</title>
    <link href="/2023/02/07/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E4%B8%80%E6%9C%AC%E9%80%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%C2%B7%E5%8C%97%E6%9E%81%E9%80%9A%E8%AE%AF%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/02/07/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E4%B8%80%E6%9C%AC%E9%80%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%C2%B7%E5%8C%97%E6%9E%81%E9%80%9A%E8%AE%AF%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1>原题</h1><p>北极的某区域共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>座村庄(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">1 ≤ n ≤ 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">500</span></span></span></span> )，每座村庄的坐标用一对整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">(x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>)表示，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 ≤ x, y ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span>。为了加强联系，决定在村庄之间建立通讯网络。</p><p>通讯工具可以是无线电收发机，也可以是卫星设备。所有的村庄都可以拥有一部无线电收发机， 且所有的无线电收发机型号相同。但卫星设备数量有限，只能给一部分村庄配备卫星设备。</p><p>不同型号的无线电收发机有一个不同的参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>，两座村庄之间的距离如果不超过d就可以用该型号的无线电收发机直接通讯，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>值越大的型号价格越贵。拥有卫星设备的两座村庄无论相距多远都可以直接通讯。</p><p>现在有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>台卫星设备，请你编写程序计算出如何分配可以使所拥有的无线电收发机的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>值最小，并保证任意两个村庄都可以直接或间接通讯</p><h2 id="输入">输入</h2><p>第一行输入包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，即测试数据的数量。</p><p>每个测试用例的第一行包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>S</mi><mo>&lt;</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 &lt;= S &lt;= 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span>(卫星数)，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>&lt;</mo><mi>P</mi><mo>&lt;</mo><mo>=</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">S &lt;P &lt;= 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">500</span></span></span></span>(前哨数)。</p><p>接下来P行，给出每个前哨（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">km</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">km</span></span></span></span>，坐标是0到10,000之间的整数）的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext><mi>x</mi><mtext>，</mtext><mi>y</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">（x，y）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">）</span></span></span></span>坐标。</p><h2 id="输出">输出</h2><p>每个样例输出一个最小d值，两位小数</p><h2 id="样例输入">样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">100</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">300</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">600</span><br><span class="hljs-symbol">150 </span><span class="hljs-number">750</span><br></code></pre></td></tr></table></figure><h2 id="样例输出">样例输出</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">212</span>.<span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>对于所有测试点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>N</mi><mo>&lt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1&lt;=N&lt;=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>。</p><h1>题目大意</h1><p>最小生成树，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>个节点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>条路径，只能连<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">p-s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>条线，输出最大的权值。</p><h1>算法</h1><p>最小生成树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">kruskall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">ka</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span></span></span>算法</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">1010</span>];<span class="hljs-comment">//并查集函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">//并查集查询</span><br><span class="hljs-keyword">if</span>(a[x]==x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> a[x]=<span class="hljs-built_in">find</span>(a[x]);<span class="hljs-comment">//路径压缩</span><br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">xy</span>&#123;<br><span class="hljs-type">double</span> x,y;<span class="hljs-comment">//xy坐标</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> a,b;<br><span class="hljs-type">double</span> w;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.w&lt;b.w;<span class="hljs-comment">//自定义排序，也可以重载运算符</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">double</span> x1,<span class="hljs-type">double</span> y1,<span class="hljs-type">double</span> x2,<span class="hljs-type">double</span> y2)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));<span class="hljs-comment">//曼哈顿距离</span><br>&#125;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskall</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//因为有多组数据，所以单独一个函数</span><br>xy point[<span class="hljs-number">1010</span>];<span class="hljs-comment">//点数组</span><br>vector&lt;node&gt;v;<br><span class="hljs-type">int</span> s,p,num=<span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> d;<br>cin&gt;&gt;s&gt;&gt;p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++) a[i]=i;<span class="hljs-comment">//并查集初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++)&#123;<br>cin&gt;&gt;point[i].x&gt;&gt;point[i].y;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=p;j++)&#123;<br><span class="hljs-keyword">if</span>(i!=j) v.<span class="hljs-built_in">push_back</span>(&#123;i,j,<span class="hljs-built_in">dis</span>(point[i].x,point[i].y,point[j].x,point[j].y)&#125;);<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-comment">//排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:v)&#123;<span class="hljs-comment">//kruskall算法</span><br><span class="hljs-type">int</span> fa=<span class="hljs-built_in">find</span>(it.a),fb=<span class="hljs-built_in">find</span>(it.b);<br><span class="hljs-keyword">if</span>(fa!=fb)&#123;<br>a[fa]=fb;<br>num++;<br><span class="hljs-keyword">if</span>(num==p-s)&#123;<br>d=it.w;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,d);<span class="hljs-comment">//最后一个就是最大的，两位小数输出</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">while</span>(n--) <span class="hljs-built_in">kruskall</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>感谢观看<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">qwq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">qwq</span></span></span></span>！</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>一本通</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记】离散化</title>
    <link href="/2023/02/07/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2023/02/07/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1>1 离散化</h1><p><strong>离散化</strong>(Discretization)：就是把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。「1」</p><p>离散化本质上可以看成是一种哈希 ，其保证数据在哈希以后仍然保持原来的全/偏序关系。<br>通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。<br>用来离散化的可以是大整数、浮点数、字符串……等等。「2」</p><p>原数据：(1,999,100000,15)</p><p>处理后：(1,3,4,2)</p><p>原数据：{100,200},{20,50000},{1,400}</p><p>处理后：{3,4},{2,6},{1,5}</p><h2 id="1-1-离散化模板">1.1 离散化模板</h2><p>模板1：使用vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">10010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-comment">//二分模板</span><br><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(v[mid]&gt;=f) r=mid;<br><span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>v.<span class="hljs-built_in">push_back</span>(a[i]);<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//排序</span><br>v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//因为unique只能把重复元素放在后面，所以要用erase删除后面的元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;<span class="hljs-built_in">find</span>(a[i]);<span class="hljs-comment">//用二分查找离散值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>模板2：使用map</p><p>因为map会自动去重和排序，而且可以使用数组下标，所以比较方便。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">10010</span>;<br><span class="hljs-type">int</span> a[N];<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;M;<span class="hljs-comment">//map容器</span><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>M[a[i]]=<span class="hljs-number">0</span>;<span class="hljs-comment">//把离散化的值加入map</span><br>&#125;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:M) it.second=cnt++;<span class="hljs-comment">//可以用auto直接迭代stl容器</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;M[a[i]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-经典例题">1.2 经典例题</h2><p><img src="https://img-blog.csdnimg.cn/20210421164844899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JldHRsZV9raW5n,size_16,color_FFFFFF,t_70" alt=""></p><p>(<a href="https://www.acwing.com/problem/content/804/">acwing802区间和</a>)</p><h3 id="1-2-1-题目大意">1.2.1 题目大意</h3><p>很显然，这是一道前缀和的题，但是数据太大（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>），所以需要用到离散化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;x,y;<br> <br><span class="hljs-type">int</span> a[<span class="hljs-number">300100</span>]=&#123;<span class="hljs-number">0</span>&#125;,s[<span class="hljs-number">300100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(v[mid]&gt;=f) r=mid;<br><span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">while</span>(n--)&#123;<br><span class="hljs-type">int</span> l,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;c);<br>x.<span class="hljs-built_in">push_back</span>(&#123;l,c&#125;);<br>v.<span class="hljs-built_in">push_back</span>(l);<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>y.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>v.<span class="hljs-built_in">push_back</span>(l);<br>v.<span class="hljs-built_in">push_back</span>(r);<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:x)&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(it.first); <br>a[t]+=it.second;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=v.<span class="hljs-built_in">size</span>();i++) s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:y)&#123;<br><span class="hljs-type">int</span> l=<span class="hljs-built_in">find</span>(it.first),r=<span class="hljs-built_in">find</span>(it.second); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>引用文献</h1><p>「1」<a href="https://baike.baidu.com/item/%E7%A6%BB%E6%95%A3%E5%8C%96/10501557">百度百科离散化</a></p><p>「2」<a href="https://blog.csdn.net/nuoyanli/article/details/103499146">离散化(补充）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
